# C语言最长公共前缀问题总结

**日期**: 2025-11-01 20:38:03

## 问题代码

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

char* longestCommonPrefix(char** strs, int strsSize);

int main(void){
    char* str[] = {"flower", "folw", "flight"};
    int strsSize = strlen(str);

    char* result = longestCommenPrefix(str, strSize);
    printf("%s\n", result);

    return EXIT_SUCCESS;
}

char* longestCommonPrefix(char** strs, int strsSize) {
    if(strsSize == 0){
        return "";
    }

    if(strsSize == 1){
        return strs;
    }

    int length = 0;
    bool inde = true;
    for(size_t i = 0; strs[0][i] != '\0' && inde; i++){
        char currentChar = strs[0][i];

        for(size_t j = 0; j < strsSize; j++){
            if(strs[j][i] == '\0' || currentChar != strs[j][i]){
                inde = false;
                break;
            }
        }

        length++;
    }

    char* result = malloc(length + 1);
    strncpy(result, &strs, length);
    result[length] = '\0';

    return result;
}
```

## 编译错误列表

### 1. 头文件错误
**错误**: `#include <bool.h>` 不存在
**原因**: C语言中没有 `bool.h` 这个头文件
**解决**: 使用 `#include <stdbool.h>` 来获取 `bool`、`true`、`false` 类型和常量

```c
#include <stdbool.h>  // 正确的布尔类型头文件
```

---

### 2. 数组大小计算错误
**错误**: `int strsSize = strlen(str);` (第 9 行)
**问题**:
- `strlen()` 用于计算字符串长度，参数类型是 `const char*`
- `str` 是 `char**` 类型（字符串数组），类型不匹配

**解决**: 使用 `sizeof` 计算数组元素个数

```c
int strsSize = sizeof(str) / sizeof(str[0]);  // 推荐方式
// 或
int strsSize = sizeof(str) / sizeof(char*);   // 也可以但不推荐
```

**为什么推荐 `sizeof(str[0])`**:
- 通用性更好，适用于任何数组类型
- 即使改变数组元素类型，代码仍然正确
- 代码意图更清晰

---

### 3. 函数名拼写错误
**错误**: `longestCommenPrefix` (第 11 行)
**正确**: `longestCommonPrefix`
**提示**: 编译器提示 "did you mean 'longestCommonPrefix'?"

---

### 4. 变量名拼写错误
**错误**: `strSize` (第 11 行)
**正确**: `strsSize`
**提示**: 编译器提示 "did you mean 'strsSize'?"

---

### 5. 返回类型错误
**错误**: `return strs;` (第 23 行)
**问题**:
- 函数返回类型是 `char*`（单个字符串）
- `strs` 是 `char**` 类型（字符串数组）

**解决**: 返回第一个字符串的副本

```c
if(strsSize == 1){
    char* result = malloc(strlen(strs[0]) + 1);
    strcpy(result, strs[0]);
    return result;
}
```

---

### 6. length 计算多 1 的问题
**错误**: `length++` 的位置不当 (第 38 行)

**问题分析**:
```c
for(size_t i = 0; strs[0][i] != '\0' && inde; i++){
    char currentChar = strs[0][i];

    for(size_t j = 0; j < strsSize; j++){
        if(strs[j][i] == '\0' || currentChar != strs[j][i]){
            inde = false;
            break;  // 跳出内循环
        }
    }

    length++;  // ❌ 问题：即使不匹配，这行代码仍会执行！
}
```

**执行过程示例** (字符串: `{"flower", "flow", "flight"}`):
- i=0: 检查 'f'，匹配 → `length++` (length=1)
- i=1: 检查 'l'，匹配 → `length++` (length=2)
- i=2: 检查 'o'，不匹配 → 设置 `inde=false`，跳出内循环
- **问题**: 跳出内循环后，外循环仍然执行 `length++` → length=3 (多了1)

**解决方案 1**: 添加条件判断
```c
for(size_t i = 0; strs[0][i] != '\0' && inde; i++){
    char currentChar = strs[0][i];

    for(size_t j = 0; j < strsSize; j++){
        if(strs[j][i] == '\0' || currentChar != strs[j][i]){
            inde = false;
            break;
        }
    }

    if(inde) {  // ✓ 只有匹配时才增加长度
        length++;
    }
}
```

**解决方案 2**: 使用 goto 跳出外循环
```c
for(size_t i = 0; strs[0][i] != '\0'; i++){
    char currentChar = strs[0][i];

    for(size_t j = 0; j < strsSize; j++){
        if(strs[j][i] == '\0' || currentChar != strs[j][i]){
            goto done;  // 直接跳出双层循环
        }
    }
    length++;  // 只有所有字符串都匹配才会执行到这里
}
done:
```

---

### 7. strncpy 参数错误
**错误**: `strncpy(result, &strs, length);` (第 42 行)
**问题**:
- `&strs` 的类型是 `char***`（指向字符串数组的指针）
- `strncpy` 需要的第二个参数类型是 `const char*`

**解决**: 复制第一个字符串
```c
strncpy(result, strs[0], length);  // strs[0] 是第一个字符串
```

---

## 完整修复后的代码

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

char* longestCommonPrefix(char** strs, int strsSize);

int main(void){
    char* str[] = {"flower", "flow", "flight"};
    int strsSize = sizeof(str) / sizeof(str[0]);  // 修复：计算数组元素个数

    char* result = longestCommonPrefix(str, strsSize);  // 修复：拼写错误
    printf("最长公共前缀: \"%s\"\n", result);

    free(result);  // 释放动态分配的内存
    return EXIT_SUCCESS;
}

char* longestCommonPrefix(char** strs, int strsSize) {
    if(strsSize == 0){
        char* empty = malloc(1);
        empty[0] = '\0';
        return empty;
    }

    if(strsSize == 1){
        char* result = malloc(strlen(strs[0]) + 1);  // 修复：返回副本
        strcpy(result, strs[0]);
        return result;
    }

    int length = 0;
    bool inde = true;
    for(size_t i = 0; strs[0][i] != '\0' && inde; i++){
        char currentChar = strs[0][i];

        for(size_t j = 0; j < strsSize; j++){
            if(strs[j][i] == '\0' || currentChar != strs[j][i]){
                inde = false;
                break;
            }
        }

        if(inde) {  // 修复：只有匹配时才增加长度
            length++;
        }
    }

    char* result = malloc(length + 1);
    strncpy(result, strs[0], length);  // 修复：使用 strs[0] 而不是 &strs
    result[length] = '\0';

    return result;
}
```

---

## 关键知识点总结

### 1. 计算数组元素个数
```c
type array[] = {...};
int size = sizeof(array) / sizeof(array[0]);  // 推荐方式
```

### 2. 布尔类型使用
```c
#include <stdbool.h>  // 必须包含此头文件
bool flag = true;     // 或 false
```

### 3. 字符串长度 vs 数组大小
- `strlen(str)`: 计算字符串长度（不包括 `\0`）
- `sizeof(arr)`: 计算数组占用的字节数
- `sizeof(arr) / sizeof(arr[0])`: 计算数组元素个数

### 4. 动态内存管理
```c
char* str = malloc(size);  // 分配内存
// 使用 str...
free(str);                 // 释放内存
```

### 5. 返回字符串常量的问题
```c
// ❌ 错误：返回字符串常量
if(strsSize == 0){
    return "";  // 不应返回字符串字面量
}

// ✓ 正确：分配新内存
if(strsSize == 0){
    char* empty = malloc(1);
    empty[0] = '\0';
    return empty;
}
```

### 6. 循环中的 length 计算
在嵌套循环中要特别注意计数器的增加时机，确保只在满足条件时才增加。

---

## 编译和运行

```bash
# 编译
gcc 14.c -o 14 -Wall -Wextra

# 运行
./14
```

**输出**:
```
最长公共前缀: "fl"
```

---

## 学习要点

1. **仔细检查头文件**: 确保使用正确的标准库头文件
2. **类型匹配**: 注意函数参数和返回值的类型匹配
3. **拼写检查**: 函数名和变量名要拼写正确
4. **循环逻辑**: 嵌套循环中的计数器增加要谨慎
5. **内存管理**: 动态分配的内存要记得释放
6. **编译器警告**: 认真阅读编译器的警告和提示信息

---

**备注**: 本文档记录了在实现 LeetCode 第 14 题"最长公共前缀"时遇到的所有编译错误和逻辑错误，以及相应的解决方案。
