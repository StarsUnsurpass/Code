# C 语言实现三数之和（LeetCode 15）

**日期**: 2025-11-01 21:03:20

## 问题描述

给你一个整数数组 `nums`，判断是否存在三元组 `[nums[i], nums[j], nums[k]]` 满足 `i != j`、`i != k` 且 `j != k`，同时还满足 `nums[i] + nums[j] + nums[k] == 0`。

请你返回所有和为 0 且不重复的三元组。

**注意**: 答案中不可以包含重复的三元组。

### 示例

**示例 1**:
```
输入: nums = [-1,0,1,2,-1,-4]
输出: [[-1,-1,2],[-1,0,1]]
解释:
nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0
nums[1] + nums[3] + nums[4] = 0 + (-1) + (-1) = -2 (不满足)
nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0
```

**示例 2**:
```
输入: nums = [0,1,1]
输出: []
解释: 唯一可能的三元组和不为 0
```

**示例 3**:
```
输入: nums = [0,0,0]
输出: [[0,0,0]]
解释: 唯一可能的三元组和为 0
```

---

## 算法思想

### 核心思路: 排序 + 双指针

1. **排序数组**: 使相同元素相邻，便于去重和使用双指针
2. **固定第一个数**: 外层循环遍历数组，固定一个数作为三元组的第一个数
3. **双指针查找**: 在剩余数组中用双指针寻找另外两个数
4. **去重处理**: 在三个位置都要跳过重复元素

### 时间复杂度
- **排序**: O(n log n)
- **双层循环**: O(n²)
- **总时间复杂度**: **O(n²)**

### 空间复杂度
- **O(1)** (不包括返回结果的空间)

---

## qsort 函数详解

### 函数原型

```c
void qsort(void *base, size_t nitems, size_t size,
           int (*compar)(const void *, const void *));
```

### 参数说明

| 参数 | 说明 | 在代码中的值 |
|------|------|--------------|
| `void *base` | 要排序的数组指针 | `nums` |
| `size_t nitems` | 数组元素个数 | `numsSize` |
| `size_t size` | 每个元素的字节数 | `sizeof(int)` (通常是 4) |
| `int (*compar)()` | 比较函数指针 | `compare` |

### 比较函数

```c
int compare(const void* a, const void* b) {
    return (*(int*)a - *(int*)b);
}
```

**返回值规则**:
- **返回负数** (< 0): `a` 排在 `b` 前面（升序）
- **返回 0**: `a` 和 `b` 相等
- **返回正数** (> 0): `a` 排在 `b` 后面（升序）

**类型转换过程**:
```c
const void* a     // void 指针（通用类型）
(int*)a           // 转换为 int 指针
*(int*)a          // 解引用，获取 int 值
```

**示例**:
```c
输入: [-1, 0, 1, 2, -1, -4]
排序后: [-4, -1, -1, 0, 1, 2]
```

### 为什么要排序？

1. **便于去重**: 相同元素会相邻
2. **支持双指针**: 可以根据和的大小移动指针
3. **提前终止**: 如果最小数 > 0，不可能有和为 0 的三元组

### qsort 函数的常见用法

#### 1. 整数数组排序

**升序排序**:
```c
int compare_asc(const void* a, const void* b) {
    return (*(int*)a - *(int*)b);
}

int arr[] = {5, 2, 8, 1, 9};
qsort(arr, 5, sizeof(int), compare_asc);
// 结果: [1, 2, 5, 8, 9]
```

**降序排序**:
```c
int compare_desc(const void* a, const void* b) {
    return (*(int*)b - *(int*)a);  // 注意 a 和 b 的顺序反过来
}

int arr[] = {5, 2, 8, 1, 9};
qsort(arr, 5, sizeof(int), compare_desc);
// 结果: [9, 8, 5, 2, 1]
```

**按绝对值排序**:
```c
int compare_abs(const void* a, const void* b) {
    int abs_a = abs(*(int*)a);
    int abs_b = abs(*(int*)b);
    return abs_a - abs_b;
}

int arr[] = {-5, 2, -8, 1, 9};
qsort(arr, 5, sizeof(int), compare_abs);
// 结果: [1, 2, -5, -8, 9]
```

**防止整数溢出的安全写法**:
```c
int compare_safe(const void* a, const void* b) {
    int num1 = *(int*)a;
    int num2 = *(int*)b;

    if (num1 < num2) return -1;
    if (num1 > num2) return 1;
    return 0;
}
```

#### 2. 浮点数数组排序

```c
int compare_double(const void* a, const void* b) {
    double diff = (*(double*)a - *(double*)b);

    if (diff < 0) return -1;
    if (diff > 0) return 1;
    return 0;
}

double arr[] = {3.14, 1.41, 2.71, 0.58};
qsort(arr, 4, sizeof(double), compare_double);
// 结果: [0.58, 1.41, 2.71, 3.14]
```

#### 3. 字符串数组排序

```c
int compare_string(const void* a, const void* b) {
    // a 和 b 是指向 char* 的指针，需要强制转换为 char**
    return strcmp(*(char**)a, *(char**)b);
}

char* fruits[] = {"banana", "apple", "cherry", "date"};
qsort(fruits, 4, sizeof(char*), compare_string);
// 结果: ["apple", "banana", "cherry", "date"]
```

**按字符串长度排序**:
```c
int compare_string_length(const void* a, const void* b) {
    char* str1 = *(char**)a;
    char* str2 = *(char**)b;
    return strlen(str1) - strlen(str2);
}

char* words[] = {"hi", "hello", "a", "world"};
qsort(words, 4, sizeof(char*), compare_string_length);
// 结果: ["a", "hi", "hello", "world"]
```

#### 4. 结构体数组排序

```c
typedef struct {
    char name[50];
    int age;
    double score;
} Student;

// 按年龄排序
int compare_by_age(const void* a, const void* b) {
    Student* s1 = (Student*)a;
    Student* s2 = (Student*)b;
    return s1->age - s2->age;
}

// 按分数排序（降序）
int compare_by_score(const void* a, const void* b) {
    Student* s1 = (Student*)a;
    Student* s2 = (Student*)b;

    if (s1->score < s2->score) return 1;   // 注意这里反过来
    if (s1->score > s2->score) return -1;
    return 0;
}

// 按姓名排序
int compare_by_name(const void* a, const void* b) {
    Student* s1 = (Student*)a;
    Student* s2 = (Student*)b;
    return strcmp(s1->name, s2->name);
}

Student students[] = {
    {"Alice", 20, 85.5},
    {"Bob", 19, 92.0},
    {"Charlie", 21, 78.3}
};

// 按年龄排序
qsort(students, 3, sizeof(Student), compare_by_age);
```

**多字段排序**（先按年龄，年龄相同按分数）:
```c
int compare_multi(const void* a, const void* b) {
    Student* s1 = (Student*)a;
    Student* s2 = (Student*)b;

    // 先比较年龄
    if (s1->age != s2->age) {
        return s1->age - s2->age;
    }

    // 年龄相同，比较分数
    if (s1->score < s2->score) return -1;
    if (s1->score > s2->score) return 1;
    return 0;
}
```

#### 5. 二维数组/数组的数组排序

```c
// 按第一个元素排序
int compare_array(const void* a, const void* b) {
    int* arr1 = *(int**)a;
    int* arr2 = *(int**)b;
    return arr1[0] - arr2[0];
}

int* intervals[3];
int arr1[] = {3, 5};
int arr2[] = {1, 2};
int arr3[] = {4, 6};
intervals[0] = arr1;
intervals[1] = arr2;
intervals[2] = arr3;

qsort(intervals, 3, sizeof(int*), compare_array);
// 结果: [[1,2], [3,5], [4,6]]
```

#### 6. 指针数组排序

```c
int compare_int_ptr(const void* a, const void* b) {
    int* p1 = *(int**)a;
    int* p2 = *(int**)b;
    return *p1 - *p2;  // 按指针指向的值排序
}

int val1 = 30, val2 = 10, val3 = 20;
int* ptrs[] = {&val1, &val2, &val3};

qsort(ptrs, 3, sizeof(int*), compare_int_ptr);
// 排序后 ptrs 指向的值顺序: 10, 20, 30
```

#### 7. 完整示例程序

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// 整数升序
int compare_int(const void* a, const void* b) {
    return (*(int*)a - *(int*)b);
}

// 字符串排序
int compare_str(const void* a, const void* b) {
    return strcmp(*(char**)a, *(char**)b);
}

// 结构体
typedef struct {
    char name[20];
    int score;
} Student;

int compare_student(const void* a, const void* b) {
    return ((Student*)b)->score - ((Student*)a)->score;  // 按分数降序
}

int main() {
    // 1. 整数排序
    printf("=== 整数排序 ===\n");
    int nums[] = {5, 2, 8, 1, 9, 3};
    int nums_size = sizeof(nums) / sizeof(nums[0]);

    qsort(nums, nums_size, sizeof(int), compare_int);

    printf("排序后: ");
    for (int i = 0; i < nums_size; i++) {
        printf("%d ", nums[i]);
    }
    printf("\n\n");

    // 2. 字符串排序
    printf("=== 字符串排序 ===\n");
    char* fruits[] = {"banana", "apple", "cherry", "date"};
    int fruits_size = sizeof(fruits) / sizeof(fruits[0]);

    qsort(fruits, fruits_size, sizeof(char*), compare_str);

    printf("排序后: ");
    for (int i = 0; i < fruits_size; i++) {
        printf("%s ", fruits[i]);
    }
    printf("\n\n");

    // 3. 结构体排序
    printf("=== 结构体排序（按分数降序）===\n");
    Student students[] = {
        {"Alice", 85},
        {"Bob", 92},
        {"Charlie", 78},
        {"David", 95}
    };
    int students_size = sizeof(students) / sizeof(students[0]);

    qsort(students, students_size, sizeof(Student), compare_student);

    printf("排序后:\n");
    for (int i = 0; i < students_size; i++) {
        printf("  %s: %d\n", students[i].name, students[i].score);
    }

    return 0;
}
```

**输出**:
```
=== 整数排序 ===
排序后: 1 2 3 5 8 9

=== 字符串排序 ===
排序后: apple banana cherry date

=== 结构体排序（按分数降序）===
排序后:
  David: 95
  Bob: 92
  Alice: 85
  Charlie: 78
```

### qsort 注意事项

1. **整数溢出问题**:
   ```c
   // ❌ 可能溢出
   return (*(int*)a - *(int*)b);

   // ✓ 更安全
   int x = *(int*)a, y = *(int*)b;
   return (x > y) - (x < y);  // 返回 -1, 0, 或 1
   ```

2. **浮点数比较不能直接相减**:
   ```c
   // ❌ 错误：不能直接返回浮点数
   return (*(double*)a - *(double*)b);

   // ✓ 正确
   double diff = *(double*)a - *(double*)b;
   return (diff > 0) - (diff < 0);
   ```

3. **类型转换要正确**:
   ```c
   // 对于 int 数组
   int* num = (int*)a;

   // 对于 char* 数组（字符串数组）
   char** str = (char**)a;

   // 对于结构体数组
   Student* student = (Student*)a;
   ```

4. **稳定性**:
   - qsort 不保证稳定性（相等元素的相对顺序可能改变）
   - 如果需要稳定排序，需要在比较函数中考虑原始顺序

---

## 双指针算法详解

### 基本思路

固定一个数 `nums[i]`，在剩余数组 `[i+1, numsSize-1]` 中用双指针找两个数，使三数之和为 0。

### 指针移动规则

```
sum = nums[i] + nums[left] + nums[right]

如果 sum == 0:  找到解，记录结果，left++, right--
如果 sum < 0:   和太小，需要增大 → left++
如果 sum > 0:   和太大，需要减小 → right--
```

### 为什么双指针有效？

**关键**: 数组已排序

- 当 `sum < 0` 时，需要增大和
  - `nums[left+1] > nums[left]`（排序性质）
  - 所以 `left++` 会使和变大

- 当 `sum > 0` 时���需要减小和
  - `nums[right-1] < nums[right]`（排序性质）
  - 所以 `right--` 会使和变小

### 图解示例

**输入**: `[-1, 0, 1, 2, -1, -4]`
**排序后**: `[-4, -1, -1, 0, 1, 2]`

#### 第一轮: i = 0 (nums[i] = -4)

```
[-4, -1, -1, 0, 1, 2]
  ↑   ↑           ↑
  i  left       right

sum = -4 + (-1) + 2 = -3 (< 0) → left++
```

```
[-4, -1, -1, 0, 1, 2]
  ↑       ↑       ↑
  i      left   right

sum = -4 + (-1) + 2 = -3 (< 0) → left++
```

```
[-4, -1, -1, 0, 1, 2]
  ↑           ↑   ↑
  i          left right

sum = -4 + 0 + 2 = -2 (< 0) → left++
```

```
[-4, -1, -1, 0, 1, 2]
  ↑              ↑↑
  i            left/right

sum = -4 + 1 + 2 = -1 (< 0) → left++
left >= right，退出循环
```

#### 第二轮: i = 1 (nums[i] = -1)

```
[-4, -1, -1, 0, 1, 2]
      ↑   ↑       ↑
      i  left   right

sum = -1 + (-1) + 2 = 0 ✓ 找到解: [-1, -1, 2]
跳过重复元素，left++, right--
```

```
[-4, -1, -1, 0, 1, 2]
      ↑       ↑   ↑
      i      left right

sum = -1 + 0 + 1 = 0 ✓ 找到解: [-1, 0, 1]
left++, right--
```

```
[-4, -1, -1, 0, 1, 2]
      ↑        ↑↑
      i      right/left

left >= right，退出循环
```

#### 第三轮: i = 2 (nums[i] = -1)

```c
if (i > 0 && nums[i] == nums[i - 1]) {
    continue;  // 跳过重复的第一个数
}
```

---

## 去重策略

### 1. 去重第一个数 (i)

```c
if (i > 0 && nums[i] == nums[i - 1]) {
    continue;  // 跳过重复的第一个数
}
```

**示例**:
```
[-4, -1, -1, 0, 1, 2]
      ↑   ↑
   已处理  重复，跳过
```

### 2. 去重第二个数 (left)

```c
while (left < right && nums[left] == nums[left + 1]) {
    left++;
}
```

**作用**: 找到解后，跳过所有相同的 `left` 值

### 3. 去重第三个数 (right)

```c
while (left < right && nums[right] == nums[right - 1]) {
    right--;
}
```

**作用**: 找到解后，跳过所有相同的 `right` 值

---

## 完整代码实现

```c
#include <stdio.h>
#include <stdlib.h>

/**
 * 比较函数，用于 qsort 排序
 */
int compare(const void* a, const void* b) {
    return (*(int*)a - *(int*)b);
}

/**
 * 三数之和主函数
 * 返回所有和为 0 的不重复三元组
 */
int** threeSum(int* nums, int numsSize, int* returnSize, int** returnColumnSizes) {
    // 初始化返回值
    *returnSize = 0;

    // 边界检查：少于 3 个元素无法组成三元组
    if (numsSize < 3) {
        *returnColumnSizes = NULL;
        return NULL;
    }

    // 1. 排序数组（关键步骤）
    qsort(nums, numsSize, sizeof(int), compare);

    // 2. 分配结果数组的初始空间
    int capacity = 100;  // 初始容量
    int** result = (int**)malloc(capacity * sizeof(int*));
    *returnColumnSizes = (int*)malloc(capacity * sizeof(int));

    // 3. 遍历数组，固定第一个数
    for (int i = 0; i < numsSize - 2; i++) {
        // 去重：跳过重复的第一个数
        if (i > 0 && nums[i] == nums[i - 1]) {
            continue;
        }

        // 优化：如果当前数已经大于 0，后面不可能有和为 0 的三元组
        if (nums[i] > 0) {
            break;
        }

        // 4. 使用双指针查找另外两个数
        int left = i + 1;
        int right = numsSize - 1;

        while (left < right) {
            int sum = nums[i] + nums[left] + nums[right];

            if (sum == 0) {
                // 找到一组解

                // 扩容检查
                if (*returnSize >= capacity) {
                    capacity *= 2;
                    result = (int**)realloc(result, capacity * sizeof(int*));
                    *returnColumnSizes = (int*)realloc(*returnColumnSizes, capacity * sizeof(int));
                }

                // 分配并保存这组解
                result[*returnSize] = (int*)malloc(3 * sizeof(int));
                result[*returnSize][0] = nums[i];
                result[*returnSize][1] = nums[left];
                result[*returnSize][2] = nums[right];
                (*returnColumnSizes)[*returnSize] = 3;
                (*returnSize)++;

                // 去重：跳过重复的 left
                while (left < right && nums[left] == nums[left + 1]) {
                    left++;
                }
                // 去重：跳过重复的 right
                while (left < right && nums[right] == nums[right - 1]) {
                    right--;
                }

                // 移动指针继续查找
                left++;
                right--;

            } else if (sum < 0) {
                // 和太小，移动左指针
                left++;
            } else {
                // 和太大，移动右指针
                right--;
            }
        }
    }

    return result;
}

/**
 * 打印结果
 */
void printResult(int** result, int returnSize, int* returnColumnSizes) {
    printf("[\n");
    for (int i = 0; i < returnSize; i++) {
        printf("  [%d, %d, %d]", result[i][0], result[i][1], result[i][2]);
        if (i < returnSize - 1) {
            printf(",");
        }
        printf("\n");
    }
    printf("]\n");
}

/**
 * 释放结果内存
 */
void freeResult(int** result, int returnSize) {
    for (int i = 0; i < returnSize; i++) {
        free(result[i]);
    }
    free(result);
}

int main() {
    // 测试用例 1
    printf("测试用例 1: nums = [-1,0,1,2,-1,-4]\n");
    int nums1[] = {-1, 0, 1, 2, -1, -4};
    int numsSize1 = sizeof(nums1) / sizeof(nums1[0]);
    int returnSize1;
    int* returnColumnSizes1;

    int** result1 = threeSum(nums1, numsSize1, &returnSize1, &returnColumnSizes1);
    printf("输出: ");
    printResult(result1, returnSize1, returnColumnSizes1);
    freeResult(result1, returnSize1);
    free(returnColumnSizes1);

    printf("\n---\n\n");

    // 测试用例 2
    printf("测试用例 2: nums = [0,1,1]\n");
    int nums2[] = {0, 1, 1};
    int numsSize2 = sizeof(nums2) / sizeof(nums2[0]);
    int returnSize2;
    int* returnColumnSizes2;

    int** result2 = threeSum(nums2, numsSize2, &returnSize2, &returnColumnSizes2);
    printf("输出: ");
    printResult(result2, returnSize2, returnColumnSizes2);
    if (result2 != NULL) {
        freeResult(result2, returnSize2);
        free(returnColumnSizes2);
    }

    printf("\n---\n\n");

    // 测试用例 3
    printf("测试用例 3: nums = [0,0,0]\n");
    int nums3[] = {0, 0, 0};
    int numsSize3 = sizeof(nums3) / sizeof(nums3[0]);
    int returnSize3;
    int* returnColumnSizes3;

    int** result3 = threeSum(nums3, numsSize3, &returnSize3, &returnColumnSizes3);
    printf("输出: ");
    printResult(result3, returnSize3, returnColumnSizes3);
    freeResult(result3, returnSize3);
    free(returnColumnSizes3);

    printf("\n---\n\n");

    // 测试用例 4
    printf("测试用例 4: nums = [-2,0,1,1,2]\n");
    int nums4[] = {-2, 0, 1, 1, 2};
    int numsSize4 = sizeof(nums4) / sizeof(nums4[0]);
    int returnSize4;
    int* returnColumnSizes4;

    int** result4 = threeSum(nums4, numsSize4, &returnSize4, &returnColumnSizes4);
    printf("输出: ");
    printResult(result4, returnSize4, returnColumnSizes4);
    freeResult(result4, returnSize4);
    free(returnColumnSizes4);

    return 0;
}
```

---

## 编译和运行

```bash
# 编译
gcc 15.c -o 15 -Wall -Wextra

# 运行
./15
```

### 预期输出

```
测试用例 1: nums = [-1,0,1,2,-1,-4]
输出: [
  [-1, -1, 2],
  [-1, 0, 1]
]

---

测试用例 2: nums = [0,1,1]
输出: [
]

---

测试用例 3: nums = [0,0,0]
输出: [
  [0, 0, 0]
]

---

测试用例 4: nums = [-2,0,1,1,2]
输出: [
  [-2, 0, 2],
  [-2, 1, 1]
]
```

---

## 代码关键点总结

### 1. 为什么外层循环是 `i < numsSize - 2`？

```c
for (int i = 0; i < numsSize - 2; i++)
```

- 需要至少留下 2 个元素给 `left` 和 `right`
- 如果 `i = numsSize - 1`，没有元素留给 `left` 和 `right`

### 2. 动态扩容

```c
if (*returnSize >= capacity) {
    capacity *= 2;
    result = (int**)realloc(result, capacity * sizeof(int*));
    *returnColumnSizes = (int*)realloc(*returnColumnSizes, capacity * sizeof(int));
}
```

- 初始容量为 100
- 当结果数量超过容量时，容量翻倍
- 使用 `realloc` 重新分配内存

### 3. 内存管理

```c
// 分配每组解的内存
result[*returnSize] = (int*)malloc(3 * sizeof(int));

// 使用完后释放
void freeResult(int** result, int returnSize) {
    for (int i = 0; i < returnSize; i++) {
        free(result[i]);  // 释放每组解
    }
    free(result);  // 释放结果数组
}
```

### 4. 提前终止优化

```c
if (nums[i] > 0) {
    break;  // 最小的数都大于 0，不可能有和为 0 的三元组
}
```

- 因为数组已排序
- 如果 `nums[i] > 0`，后面所有数都 > 0
- 三个正数之和不可能为 0

---

## 算法优势

1. **时间效率**: O(n²)，比暴力枚举 O(n³) 快得多
2. **空间效率**: O(1)，不需要额外的哈希表
3. **自动去重**: 排序后跳过重复元素很简单
4. **易于理解**: 双指针思路清晰

---

## 相关变体题目

### 1. 两数之和（LeetCode 1）
- 使用哈希表，O(n) 时间复杂度

### 2. 最接近的三数之和（LeetCode 16）
- 同样使用排序 + 双指针
- 不需要等于目标值，只需要最接近

### 3. 四数之和（LeetCode 18）
- 再套一层循环，固定两个数
- 时间复杂度 O(n³)

---

## 常见问题

### Q1: 为什么不用三层循环暴力枚举？

**A**: 时间复杂度太高
- 暴力枚举: O(n³)
- 排序 + 双指针: O(n²)
- 对于 `n = 1000`，差距是 1000 倍

### Q2: 可以用哈希表吗？

**A**: 可以，但去重���较麻烦
- 需要额外的 Set 或 Map 来存储已找到的三元组
- 需要对三元组进行排序或哈希来判断重复
- 空间复杂度 O(n)

### Q3: 如果不要求去重呢？

**A**: 可以去掉所有去重的代码，逻辑更简单

### Q4: 整数溢出怎么办？

**A**: 改进比较函数
```c
int compare(const void* a, const void* b) {
    int num1 = *(int*)a;
    int num2 = *(int*)b;

    if (num1 < num2) return -1;
    if (num1 > num2) return 1;
    return 0;
}
```

---

## 学习要点

1. **排序的作用**: 为双指针创造条件，简化去重
2. **双指针技巧**: 利用排序性质，根据和的大小移动指针
3. **去重策略**: 在三个位置都要跳过重复元素
4. **动态扩容**: 使用 `realloc` 处理结果数组大小不确定的情况
5. **内存管理**: 记得释放所有动态分配的内存

---

**备注**: 本文档详细记录了 LeetCode 第 15 题"三数之和"的 C 语言实现，包括算法思想、代码实现和关键知识点。
